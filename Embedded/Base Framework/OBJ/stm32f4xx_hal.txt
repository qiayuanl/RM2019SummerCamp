; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\stm32f4xx_hal.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\stm32f4xx_hal.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FreeRTOS -I.\MPU9250\DMP -I.\MPU9250 -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=.\obj\stm32f4xx_hal.crf HALLIB\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal.c]
                          THUMB

                          AREA ||i.HAL_DBGMCU_DisableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGSleepMode PROC
;;;415      */
;;;416    void HAL_DBGMCU_DisableDBGSleepMode(void)
000000  4803              LDR      r0,|L1.16|
;;;417    {
;;;418      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6840              LDR      r0,[r0,#4]
000004  f0200001          BIC      r0,r0,#1
000008  4901              LDR      r1,|L1.16|
00000a  6048              STR      r0,[r1,#4]
;;;419    }
00000c  4770              BX       lr
;;;420    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStandbyMode PROC
;;;451      */
;;;452    void HAL_DBGMCU_DisableDBGStandbyMode(void)
000000  4803              LDR      r0,|L2.16|
;;;453    {
;;;454      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6840              LDR      r0,[r0,#4]
000004  f0200004          BIC      r0,r0,#4
000008  4901              LDR      r1,|L2.16|
00000a  6048              STR      r0,[r1,#4]
;;;455    }
00000c  4770              BX       lr
;;;456    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStopMode PROC
;;;433      */
;;;434    void HAL_DBGMCU_DisableDBGStopMode(void)
000000  4803              LDR      r0,|L3.16|
;;;435    {
;;;436      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6840              LDR      r0,[r0,#4]
000004  f0200002          BIC      r0,r0,#2
000008  4901              LDR      r1,|L3.16|
00000a  6048              STR      r0,[r1,#4]
;;;437    }
00000c  4770              BX       lr
;;;438    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGSleepMode PROC
;;;406      */
;;;407    void HAL_DBGMCU_EnableDBGSleepMode(void)
000000  4803              LDR      r0,|L4.16|
;;;408    {
;;;409      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6840              LDR      r0,[r0,#4]
000004  f0400001          ORR      r0,r0,#1
000008  4901              LDR      r1,|L4.16|
00000a  6048              STR      r0,[r1,#4]
;;;410    }
00000c  4770              BX       lr
;;;411    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStandbyMode PROC
;;;442      */
;;;443    void HAL_DBGMCU_EnableDBGStandbyMode(void)
000000  4803              LDR      r0,|L5.16|
;;;444    {
;;;445      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6840              LDR      r0,[r0,#4]
000004  f0400004          ORR      r0,r0,#4
000008  4901              LDR      r1,|L5.16|
00000a  6048              STR      r0,[r1,#4]
;;;446    }
00000c  4770              BX       lr
;;;447    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStopMode PROC
;;;424      */
;;;425    void HAL_DBGMCU_EnableDBGStopMode(void)
000000  4803              LDR      r0,|L6.16|
;;;426    {
;;;427      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6840              LDR      r0,[r0,#4]
000004  f0400002          ORR      r0,r0,#2
000008  4901              LDR      r1,|L6.16|
00000a  6048              STR      r0,[r1,#4]
;;;428    }
00000c  4770              BX       lr
;;;429    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      0xe0042000

                          AREA ||i.HAL_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_DeInit PROC
;;;199      */
;;;200    HAL_StatusTypeDef HAL_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;201    {
;;;202      /* Reset of all peripherals */
;;;203      __HAL_RCC_APB1_FORCE_RESET();
000002  f04f30ff          MOV      r0,#0xffffffff
000006  490e              LDR      r1,|L7.64|
000008  6008              STR      r0,[r1,#0]
;;;204      __HAL_RCC_APB1_RELEASE_RESET();
00000a  2000              MOVS     r0,#0
00000c  6008              STR      r0,[r1,#0]
;;;205    
;;;206      __HAL_RCC_APB2_FORCE_RESET();
00000e  1e40              SUBS     r0,r0,#1
000010  1d09              ADDS     r1,r1,#4
000012  6008              STR      r0,[r1,#0]
;;;207      __HAL_RCC_APB2_RELEASE_RESET();
000014  2000              MOVS     r0,#0
000016  6008              STR      r0,[r1,#0]
;;;208    
;;;209      __HAL_RCC_AHB1_FORCE_RESET();
000018  1e40              SUBS     r0,r0,#1
00001a  4909              LDR      r1,|L7.64|
00001c  3910              SUBS     r1,r1,#0x10
00001e  6008              STR      r0,[r1,#0]
;;;210      __HAL_RCC_AHB1_RELEASE_RESET();
000020  2000              MOVS     r0,#0
000022  6008              STR      r0,[r1,#0]
;;;211    
;;;212      __HAL_RCC_AHB2_FORCE_RESET();
000024  1e40              SUBS     r0,r0,#1
000026  1d09              ADDS     r1,r1,#4
000028  6008              STR      r0,[r1,#0]
;;;213      __HAL_RCC_AHB2_RELEASE_RESET();
00002a  2000              MOVS     r0,#0
00002c  6008              STR      r0,[r1,#0]
;;;214    
;;;215      __HAL_RCC_AHB3_FORCE_RESET();
00002e  1e40              SUBS     r0,r0,#1
000030  1d09              ADDS     r1,r1,#4
000032  6008              STR      r0,[r1,#0]
;;;216      __HAL_RCC_AHB3_RELEASE_RESET();
000034  2000              MOVS     r0,#0
000036  6008              STR      r0,[r1,#0]
;;;217    
;;;218      /* De-Init the low level hardware */
;;;219      HAL_MspDeInit();
000038  f7fffffe          BL       HAL_MspDeInit
;;;220        
;;;221      /* Return function status */
;;;222      return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;223    }
00003e  bd10              POP      {r4,pc}
;;;224    
                          ENDP

                  |L7.64|
                          DCD      0x40023820

                          AREA ||i.HAL_DisableCompensationCell||, CODE, READONLY, ALIGN=2

                  HAL_DisableCompensationCell PROC
;;;473      */
;;;474    void HAL_DisableCompensationCell(void)
000000  2000              MOVS     r0,#0
;;;475    {
;;;476      *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)DISABLE;
000002  2101              MOVS     r1,#1
000004  fa91f1a1          RBIT     r1,r1
000008  fab1f181          CLZ      r1,r1
00000c  4a02              LDR      r2,|L8.24|
00000e  eb020181          ADD      r1,r2,r1,LSL #2
000012  f8c10400          STR      r0,[r1,#0x400]
;;;477    }
000016  4770              BX       lr
;;;478    
                          ENDP

                  |L8.24|
                          DCD      0x42270000

                          AREA ||i.HAL_DisableMemorySwappingBank||, CODE, READONLY, ALIGN=2

                  HAL_DisableMemorySwappingBank PROC
;;;505      */
;;;506    void HAL_DisableMemorySwappingBank(void)
000000  2000              MOVS     r0,#0
;;;507    {
;;;508    
;;;509      *(__IO uint32_t *)UFB_MODE_BB = (uint32_t)DISABLE;
000002  f44f7180          MOV      r1,#0x100
000006  fa91f1a1          RBIT     r1,r1
00000a  fab1f181          CLZ      r1,r1
00000e  4a02              LDR      r2,|L9.24|
000010  f8420021          STR      r0,[r2,r1,LSL #2]
;;;510    }
000014  4770              BX       lr
;;;511    #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      0x42270000

                          AREA ||i.HAL_EnableCompensationCell||, CODE, READONLY, ALIGN=2

                  HAL_EnableCompensationCell PROC
;;;462      */
;;;463    void HAL_EnableCompensationCell(void)
000000  2001              MOVS     r0,#1
;;;464    {
;;;465      *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)ENABLE;
000002  fa90f1a0          RBIT     r1,r0
000006  fab1f181          CLZ      r1,r1
00000a  4a03              LDR      r2,|L10.24|
00000c  eb020181          ADD      r1,r2,r1,LSL #2
000010  f8c10400          STR      r0,[r1,#0x400]
;;;466    }
000014  4770              BX       lr
;;;467    
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      0x42270000

                          AREA ||i.HAL_EnableMemorySwappingBank||, CODE, READONLY, ALIGN=2

                  HAL_EnableMemorySwappingBank PROC
;;;490      */
;;;491    void HAL_EnableMemorySwappingBank(void)
000000  2001              MOVS     r0,#1
;;;492    {
;;;493      *(__IO uint32_t *)UFB_MODE_BB = (uint32_t)ENABLE;
000002  0201              LSLS     r1,r0,#8
000004  fa91f1a1          RBIT     r1,r1
000008  fab1f181          CLZ      r1,r1
00000c  4a01              LDR      r2,|L11.20|
00000e  f8420021          STR      r0,[r2,r1,LSL #2]
;;;494    }
000012  4770              BX       lr
;;;495    
                          ENDP

                  |L11.20|
                          DCD      0x42270000

                          AREA ||i.HAL_GetDEVID||, CODE, READONLY, ALIGN=2

                  HAL_GetDEVID PROC
;;;397      */
;;;398    uint32_t HAL_GetDEVID(void)
000000  4802              LDR      r0,|L12.12|
;;;399    {
;;;400       return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
000002  6800              LDR      r0,[r0,#0]
000004  f3c0000b          UBFX     r0,r0,#0,#12
;;;401    }
000008  4770              BX       lr
;;;402    
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetHalVersion||, CODE, READONLY, ALIGN=2

                  HAL_GetHalVersion PROC
;;;379      */
;;;380    uint32_t HAL_GetHalVersion(void)
000000  4800              LDR      r0,|L13.4|
;;;381    {
;;;382     return __STM32F4xx_HAL_VERSION;
;;;383    }
000002  4770              BX       lr
;;;384    
                          ENDP

                  |L13.4|
                          DCD      0x01040200

                          AREA ||i.HAL_GetREVID||, CODE, READONLY, ALIGN=2

                  HAL_GetREVID PROC
;;;388      */
;;;389    uint32_t HAL_GetREVID(void)
000000  4801              LDR      r0,|L14.8|
;;;390    {
;;;391       return((DBGMCU->IDCODE) >> 16);
000002  6800              LDR      r0,[r0,#0]
000004  0c00              LSRS     r0,r0,#16
;;;392    }
000006  4770              BX       lr
;;;393    
                          ENDP

                  |L14.8|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetTick||, CODE, READONLY, ALIGN=2

                  HAL_GetTick PROC
;;;327      */
;;;328    __weak uint32_t HAL_GetTick(void)
000000  4801              LDR      r0,|L15.8|
;;;329    {
;;;330      return uwTick;
000002  6800              LDR      r0,[r0,#0]  ; uwTick
;;;331    }
000004  4770              BX       lr
;;;332    
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      uwTick

                          AREA ||i.HAL_IncTick||, CODE, READONLY, ALIGN=2

                  HAL_IncTick PROC
;;;316      */
;;;317    __weak void HAL_IncTick(void)
000000  4802              LDR      r0,|L16.12|
;;;318    {
;;;319      uwTick++;
000002  6800              LDR      r0,[r0,#0]  ; uwTick
000004  1c40              ADDS     r0,r0,#1
000006  4901              LDR      r1,|L16.12|
000008  6008              STR      r0,[r1,#0]  ; uwTick
;;;320    }
00000a  4770              BX       lr
;;;321    
                          ENDP

                  |L16.12|
                          DCD      uwTick

                          AREA ||i.HAL_Init||, CODE, READONLY, ALIGN=2

                  HAL_Init PROC
;;;166      */
;;;167    HAL_StatusTypeDef HAL_Init(void)
000000  b510              PUSH     {r4,lr}
;;;168    {
;;;169      /* Configure Flash prefetch, Instruction cache, Data cache */ 
;;;170    #if (INSTRUCTION_CACHE_ENABLE != 0)
;;;171       __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
000002  480c              LDR      r0,|L17.52|
000004  6800              LDR      r0,[r0,#0]
000006  f4407000          ORR      r0,r0,#0x200
00000a  490a              LDR      r1,|L17.52|
00000c  6008              STR      r0,[r1,#0]
;;;172    #endif /* INSTRUCTION_CACHE_ENABLE */
;;;173    
;;;174    #if (DATA_CACHE_ENABLE != 0)
;;;175       __HAL_FLASH_DATA_CACHE_ENABLE();
00000e  4608              MOV      r0,r1
000010  6800              LDR      r0,[r0,#0]
000012  f4406080          ORR      r0,r0,#0x400
000016  6008              STR      r0,[r1,#0]
;;;176    #endif /* DATA_CACHE_ENABLE */
;;;177    
;;;178    #if (PREFETCH_ENABLE != 0)
;;;179      __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f4407080          ORR      r0,r0,#0x100
000020  6008              STR      r0,[r1,#0]
;;;180    #endif /* PREFETCH_ENABLE */
;;;181    
;;;182      /* Set Interrupt Group Priority */
;;;183      HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);//中断优先级分组2
000022  2003              MOVS     r0,#3
000024  f7fffffe          BL       HAL_NVIC_SetPriorityGrouping
;;;184    
;;;185      /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
;;;186     // HAL_InitTick(TICK_INT_PRIORITY);
;;;187      	HAL_Systick_Init();
000028  f7fffffe          BL       HAL_Systick_Init
;;;188      /* Init the low level hardware */
;;;189      HAL_MspInit();
00002c  f7fffffe          BL       HAL_MspInit
;;;190      
;;;191      /* Return function status */
;;;192      return HAL_OK;
000030  2000              MOVS     r0,#0
;;;193    }
000032  bd10              POP      {r4,pc}
;;;194    
                          ENDP

                  |L17.52|
                          DCD      0x40023c00

                          AREA ||i.HAL_InitTick||, CODE, READONLY, ALIGN=1

                  HAL_InitTick PROC
;;;268      */
;;;269    __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
000000  b570              PUSH     {r4-r6,lr}
;;;270    {
000002  4604              MOV      r4,r0
;;;271      /*Configure the SysTick to have interrupt in 1ms time basis*/
;;;272      HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
000004  f7fffffe          BL       HAL_RCC_GetHCLKFreq
000008  f44f717a          MOV      r1,#0x3e8
00000c  fbb0f5f1          UDIV     r5,r0,r1
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       HAL_SYSTICK_Config
;;;273    
;;;274      /*Configure the SysTick IRQ priority */
;;;275      HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
000016  2200              MOVS     r2,#0
000018  4621              MOV      r1,r4
00001a  1e50              SUBS     r0,r2,#1
00001c  f7fffffe          BL       HAL_NVIC_SetPriority
;;;276    
;;;277      /* Return function status */
;;;278      return HAL_OK;
000020  2000              MOVS     r0,#0
;;;279    }
000022  bd70              POP      {r4-r6,pc}
;;;280    
                          ENDP


                          AREA ||i.HAL_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_MspDeInit PROC
;;;242      */
;;;243    __weak void HAL_MspDeInit(void)
000000  b508              PUSH     {r3,lr}
;;;244    {
;;;245      /* Prevent unused argument(s) compilation warning */
;;;246      __IO uint32_t tmpreg = 0x00;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;247      UNUSED(tmpreg);
000006  bf00              NOP      
;;;248      /* NOTE : This function Should not be modified, when the callback is needed,
;;;249                the HAL_MspDeInit could be implemented in the user file
;;;250       */ 
;;;251    }
000008  bd08              POP      {r3,pc}
;;;252    
                          ENDP


                          AREA ||i.HAL_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_MspInit PROC
;;;228      */
;;;229    __weak void HAL_MspInit(void)
000000  b508              PUSH     {r3,lr}
;;;230    {
;;;231      /* Prevent unused argument(s) compilation warning */
;;;232      __IO uint32_t tmpreg = 0x00;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;233      UNUSED(tmpreg);
000006  bf00              NOP      
;;;234      /* NOTE : This function Should not be modified, when the callback is needed,
;;;235                the HAL_MspInit could be implemented in the user file
;;;236       */
;;;237    }
000008  bd08              POP      {r3,pc}
;;;238    
                          ENDP


                          AREA ||i.HAL_ResumeTick||, CODE, READONLY, ALIGN=1

                  HAL_ResumeTick PROC
;;;369      */
;;;370    __weak void HAL_ResumeTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;371    {
;;;372      /* Enable SysTick Interrupt */
;;;373      SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
000004  6900              LDR      r0,[r0,#0x10]
000006  f0400002          ORR      r0,r0,#2
00000a  f04f21e0          MOV      r1,#0xe000e000
00000e  6108              STR      r0,[r1,#0x10]
;;;374    }
000010  4770              BX       lr
;;;375    
                          ENDP


                          AREA ||i.HAL_SuspendTick||, CODE, READONLY, ALIGN=1

                  HAL_SuspendTick PROC
;;;353      */
;;;354    __weak void HAL_SuspendTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;355    {
;;;356      /* Disable SysTick Interrupt */
;;;357      SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
000004  6900              LDR      r0,[r0,#0x10]
000006  f0200002          BIC      r0,r0,#2
00000a  f04f21e0          MOV      r1,#0xe000e000
00000e  6108              STR      r0,[r1,#0x10]
;;;358    }
000010  4770              BX       lr
;;;359    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  uwTick
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "HALLIB\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_hal_c_HAL_Init____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___15_stm32f4xx_hal_c_HAL_Init____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_hal_c_HAL_Init____REVSH|
#line 402
|__asm___15_stm32f4xx_hal_c_HAL_Init____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_hal_c_HAL_Init____RRX|
#line 587
|__asm___15_stm32f4xx_hal_c_HAL_Init____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
